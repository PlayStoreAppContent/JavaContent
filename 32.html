<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>
		</title>
		<style type="text/css">
			.cs95E872D0{text-align:left;text-indent:0pt;margin:0pt 0pt 0pt 0pt}
			.csAC91E297{color:#000000;background-color:#FFFFFF;font-family:Book Antiqua;font-size:14pt;font-weight:bold;font-style:normal;}
			.cs57154F9C{color:#000000;background-color:transparent;font-family:Book Antiqua;font-size:12pt;font-weight:normal;font-style:normal;}
			.csC2DDF68C{color:#000000;background-color:#FFFFFF;font-family:Book Antiqua;font-size:12pt;font-weight:normal;font-style:normal;}
		</style>
	</head>
	<body>
		<p class="cs95E872D0"><span class="csAC91E297">Java - I/O Stream</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp;</span></p><p class="cs95E872D0"><span class="cs57154F9C">1.Byte Streams:<br/>Generally, all the low-level streams, like keyboard input or output to a monitor or socket level data transmission goes by byte streams. In java.io package, the subclasses of Input and Output streams support these byte streams.&nbsp;<br/><br/>FileInpustStream is generally used to read byte by byte from a file and FileOutputStream is used to write byte by byte to a file.</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp;</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp;</span></p><p class="cs95E872D0"><span class="cs57154F9C">2. Character Streams:<br/>jdk 1.1 version, introduces character based streams. Character-based input and output streams( subclasses of Reader and Writer classes) provide several advantages.<br/><br/>While byte streams( subclasses of InputStream and OutputStream classes) reads 8-bit ASCII byte at a time, character-based streams reads 16-bit Unicode characters. These are introduced to support Java&#39;s internationalization.&nbsp;<br/><br/>FileReader, an indirect subclass of Reader class, is a prominent class to read characters from a file.<br/>FileReader fr = new FileReader( &quot;Demo.txt&quot; ) ;<br/>fr.read( ) ;</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp;</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp;</span></p><p class="cs95E872D0"><span class="cs57154F9C">3. Filter Streams:<br/>The java.io package provides two abstract classes that define filter streams FilterInputStream and FilterOutputStream for byte streams and FilterReader and FilterWriter for character streams.<br/><br/>A filter stream is a stream that filters data while reading and writing and adds some extra functionality which does not exist in the original source file. Example of filter streams: LineNumberInputStream, DataInputStream, and PushbackInputStream etc.&nbsp;<br/><br/>The extra functionality given by the LineNumberInputStream is, it adds line numbers in the destination file that does not exist in the source file. PushbackInputStream pushes back the extra unwanted character back to the system and is generally used in compilers and parsers etc.<br/><br/>Filter streams does not read or write to a file directly. Always input for a high-level stream is a low-level stream. And also a high level stream can be linked to another high-level stream. The following code snippet illustrates:<br/><br/>Connecting a low-level stream to a high-level stream:<br/>// a low-level stream<br/>FileInputStream fis = new FileInputStream( &quot;a.java&quot; ) ;&nbsp;<br/>// a high-level stream<br/>DataInputStream dis = new DataInputStream( fis ) ;&nbsp;<br/></span></p><p class="cs95E872D0"><span class="cs57154F9C">In the above code, fis, a low-level input stream is passed as parameter to a high-level stream, DataInputStream.&nbsp;<br/><br/>Connecting a high-level stream to another high-level stream:<br/>// a low-level stream<br/>FileInputStream fis = new FileInputStream( &quot; a.java &quot; ) ;<br/>// a high-level stream<br/>BufferedInputStream bis = new BufferedInputStream( fis ) ;&nbsp;<br/>// a high-level stream<br/>DataInputStream dis = new DataInputStream( bis ) ;&nbsp;<br/><br/>In the above code, bis, a high-level stream object is passed as a parameter to another high-level stream, DataInputStream.</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp;</span></p><p class="cs95E872D0"><span class="cs57154F9C">1. InputStream :<br/>An InputStream can be thought of like a physical stream of water flowing from a source to destination. The only difference is, instead of water bytes will be flowing. The data in an input stream is transmitted one byte at a time.<br/><br/>Java uses input streams as a means of reading data from an input source like keyboard, a file or a socket.&nbsp;<br/><br/>The InputStream class is an abstract class that serves as the base class for many input stream classes like FileInputStream, SequenceInputStream, ObjectInpustStream etc. It defines many abstract methods that are useful for all its subclasses like read(), skip() and available() etc.&nbsp;<br/><br/>2. FileInputStream :<br/>All the subclasses of abstract InputStream class, FileInputStream class is generally used for performing simple file input operations. To work with FileInputStream class, there are three steps to perform :<br/><br/>i). Open a file:&nbsp;A file can be opened in reading mode by using FileInputStream constructor as follows:<br/><br/>// throws FileNotFoundException<br/>FileInputStream fis = new FileInputStream( &quot;a.java&quot; ) ;<br/><br/>ii). Read from the file:&nbsp;Byte by byte can be read from the file by using read( ) method of the FileInputStream class as follows:<br/><br/>fis.read( ) ;&nbsp;// throws IOException<br/><br/>iii). Close the file:&nbsp;By closing the file, we can return the resources that are no longer needed to the system and can be done as follows:<br/><br/>fis.close( ) ;&nbsp;// throws IOException<br/><br/>3. FileOutputStream :<br/>All subclasses of OutputStream class, FileOutputStream class is generally used for performing simple file output operations. To work with FileOutputStream class, there are three steps to perform:<br/><br/>i). Open a file:&nbsp;A file can be opened in writing mode by using FileOutputStream constructor as follows:<br/><br/>FileOutputStream fos = new FileOutputStream( &quot;b.java&quot; ) ;<br/><br/>If the file, b.java does not exist in the current directory, a new one is created.<br/><br/>ii). Write to the file:&nbsp;Byte by byte can be written to a file by using write( ) method of the FileOutputStream class as follows:<br/><br/>fos.write( k ) ;<br/>/* where k is an ASCII int returned by the read( ) method throws IOException */<br/><br/>iii). Close the file:&nbsp;By closing the file, we can return the resources that are no longer needed to the system and can be done as follows:&nbsp;<br/><br/>fos.close( ) ;&nbsp;// throws IOException<br/><br/></span></p><p class="cs95E872D0"><span class="cs57154F9C">4. DataInputputStream :<br/>DataInputStream is a high-level stream and is a subclass of FilterInputStream. DataInputStream also implements DataInput interface. DataInputStream includes special methods like readInt( ) and readDouble( ) etc., that reads the binary representation of data types int and double.&nbsp;<br/><br/>This input stream includes a special method readLine( ) method which reads a line as a whole and returns a string. readLine( ) method of DataInputStream is deprecated, but the readLine( ) method of BufferedInputStream is not.&nbsp;<br/><br/>DataInputStream, being a high level stream, can not read and write directly and to be linked to a low level stream. DataInputStream can also be linked to another high level stream for extra functionality. Following illustrates:<br/><br/>// a low-level stream<br/>FileInputStream fis = new FileInputStream(&quot;a.java &quot;) ;<br/>// a high-level stream<br/>BufferedInputStream bis = new BufferedInputStream( fis ) ;<br/>// a high-level stream<br/>DataInputStream dis = new DataInputStream( bis ) ;&nbsp;<br/><br/>An example using DataInputStream: ( reading keyboard input )</span></p><p class="cs95E872D0"><span class="cs57154F9C">import java.io.* ;</span></p><p class="cs95E872D0"><span class="cs57154F9C">public class JavaScanf &nbsp;&nbsp;</span></p><p class="cs95E872D0"><span class="cs57154F9C">{</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp; public static void main(String args[]) throws IOException &nbsp;&nbsp;</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp; {</span></p><p class="cs95E872D0"><span class="cs57154F9C">	DataInputStream dis = new DataInputStream( System.in ) ;</span></p><p class="cs95E872D0"><span class="cs57154F9C">	System.out.println( &quot; Enter something:&quot; ) ;</span></p><p class="cs95E872D0"><span class="cs57154F9C">	String str = dis.readLine( ) ;</span></p><p class="cs95E872D0"><span class="cs57154F9C">	System.out.println( &quot; You enetered: &quot; + str ) ;</span></p><p class="cs95E872D0"><span class="cs57154F9C">	 }</span></p><p class="cs95E872D0"><span class="cs57154F9C">}</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp;</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp;</span></p><p class="cs95E872D0"><span class="csC2DDF68C">5. FileReader :</span><span class="cs57154F9C"><br/></span><span class="csC2DDF68C">jdk 1.1 version, introduces character based streams. Character-based input and output streams( subclasses of Reader and Writer classes) provide several advantages.&nbsp;</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">While byte streams( subclasses of InputStream and OutputStream classes) reads 8-bit ASCII byte at a time, character-based streams( subclasses of Reader and Writer classes) reads 16-bit Unicode characters.</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">Hierarchy:</span><span class="cs57154F9C"><br/></span><span class="csC2DDF68C">Object ----&gt; Reader ----&gt; InputStreamReader ----&gt; FileReader</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">FileReader, an indirect subclass of Reader class, is a prominent class to read characters from a file.</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">FileReader fr = new FileReader(&quot;Demo.txt&quot;) ;</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">6. RandomAccessFile :</span><span class="cs57154F9C"><br/></span><span class="csC2DDF68C">Unlike all other I/O streams, RandomAccessFile can read from a file and write to a file. Because it can both read and write, we must specify in which mode we are opening the file. This class constructor( also overloaded) takes two string arguments.&nbsp;</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">The first one specifies the file name and the second one, the mode. Only two modes are supported -r ( only for reading ) and rw ( for reading and writing ). Just like in FileInputStream, the specified file does not exist, a new one is created.&nbsp;</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">The following statement opens a file in both reading and writing modes:</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">RandomAccessFile raf = new RandomAccessFile( &quot;Demo.txt &quot;, &quot;rw&quot; );</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">Unlike all input stream classes, we can read and write to a file at any specified position with its seek( ) method. The seek( ) method specifies the byte offset from the beginning of the file.&nbsp;</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">This stream is used mainly in on-line applications like airport reservation and super bazar systems where random access of records is required.</span><span class="cs57154F9C"><br/></span></p><p class="cs95E872D0"><span class="cs57154F9C"><br/></span><span class="csC2DDF68C">7. File :</span><span class="cs57154F9C"><br/></span><span class="csC2DDF68C">Java supports files in two different classes:&nbsp;</span><span class="cs57154F9C"><br/></span><span class="csC2DDF68C">i). File&nbsp;</span><span class="cs57154F9C"><br/></span><span class="csC2DDF68C">ii). RandomAccessFile.&nbsp;</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">Both are subclasses of Object. Where we require a file name as object, we use File class.&nbsp;</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">File f1 = new File( &quot;a.java&quot; ) ;</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">FileInputStream constructor will accept this object also as follows:</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">FileInputStream fis = new FileInputStream( f1 ) ; </span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">In the above statement, f1 is the object that represents the file, a.java. The file object f1, keeps all the information about the file, a.java, including its location in the hard disk and its accessibility permissions.&nbsp;</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">It includes many query methods with which we can get a lot of information about the file. File class constructor is overloaded where we can specify the class path also( if the file is not in current directory).</span><span class="cs57154F9C"><br/><br/></span><span class="csC2DDF68C">The File constructor can refer a directory also. The File class provides a number of methods for manipulating files and directories. The methods include like canRead( ), canWrite( ), getParent( ), getAbsolutePath( ), length( ) etc.</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp;</span></p><p class="cs95E872D0"><span class="csC2DDF68C">&nbsp;</span></p><p class="cs95E872D0"><span class="cs57154F9C">8. BufferedInputStream :<br/>Buffering is specific to the BufferedInputStream and BufferedOutputStream classes.&nbsp;<br/><br/>Buffering speeds up input and output operations, by storing data. A buffered input stream reads as much data as possible even before we request for it. That is BufferedInputStream uses buffering effect.&nbsp;<br/><br/>BufferedInputStream is a high level stream as it is a subclass of FilterInputStream. Being a high level stream, it cannot read a file directly. Always it requires a low level stream like FileInputStream object as a parameter. The following is the code snippet:&nbsp;<br/><br/>FileInputStream fis = new FileInputStream(&quot;a.java&quot;) ;&nbsp;<br/>BufferedInputStream bis = new BufferedInputStream( fis ) ;<br/><br/>The following full program illustrates the use of BufferedInputStream: ( in this program a file is copied to monitor)&nbsp;</span></p><p class="cs95E872D0"><span class="cs57154F9C">	 </span></p><p class="cs95E872D0"><span class="cs57154F9C">import java.io.* ;</span></p><p class="cs95E872D0"><span class="cs57154F9C">public class UsingBuffer &nbsp;&nbsp;</span></p><p class="cs95E872D0"><span class="cs57154F9C">{</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp;public static void main(String args[]) throws IOException </span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp;{</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp; FileInputStream fis = new FileInputStream( &quot; a.java &quot; ) ;</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp; BufferedInputStream bis = new BufferedInputStream( fis ) ;</span></p><p class="cs95E872D0"><span class="cs57154F9C">		</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp; int k = 0 ; &nbsp;// just initialize as it is a local variable for compiler satisfaction</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp; StringBuffer sb = new StringBuffer( ) ; &nbsp;</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp; &nbsp;while( ( k = bis.read( ) ) &nbsp;! = &nbsp;-1 ) &nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="cs95E872D0"><span class="cs57154F9C">	{</span></p><p class="cs95E872D0"><span class="cs57154F9C">	 &nbsp;sb.append( ( char ) k ) ;</span></p><p class="cs95E872D0"><span class="cs57154F9C">	 &nbsp;}</span></p><p class="cs95E872D0"><span class="cs57154F9C">	System.out.println( sb ) ;</span></p><p class="cs95E872D0"><span class="cs57154F9C">	 }</span></p><p class="cs95E872D0"><span class="cs57154F9C">}		</span></p><p class="cs95E872D0"><span class="csC2DDF68C">&nbsp;</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp;</span></p><p class="cs95E872D0"><span class="csC2DDF68C"><br/>9. PrintStream :<br/>PrintStream class belongs to byte streams. A PrintStram adds functionality to another output stream. Special features of PrintStream are :&nbsp;<br/><br/>i). Unlike other output streams, a PrintStream never throws an IOException; instead, in exceptional situations merely set an internal flag that can be tested via the checkError method.&nbsp;<br/><br/>ii). PrintStream flushes the stream of bytes automatically. That is, the flush method is automatically invoked after a byte array is written or one of the println methods is invoked or a newline character or byte ( &#39; \n &#39; ) is written.&nbsp;<br/><br/>The PrintWriter is equivalent to PrintStream in character streams. PrintWriter class should be used in situations that require writing characters rather than bytes.&nbsp;<br/><br/>The following is the hierarchy.&nbsp;<br/>Object ---&gt; OutputStream ---&gt; FilterOutputStream ---&gt; PrintStream&nbsp;<br/><br/>The following code illustrates:</span></p><p class="cs95E872D0"><span class="csC2DDF68C">&nbsp;</span></p><p class="cs95E872D0"><span class="csC2DDF68C">import java.io.*;</span></p><p class="cs95E872D0"><span class="csC2DDF68C">public class PrintStreamDemo &nbsp;&nbsp;</span></p><p class="cs95E872D0"><span class="csC2DDF68C">{</span></p><p class="cs95E872D0"><span class="csC2DDF68C">&nbsp;public static void main( String args[ ] ) &nbsp;&nbsp;</span></p><p class="cs95E872D0"><span class="csC2DDF68C">	{</span></p><p class="cs95E872D0"><span class="csC2DDF68C">		PrintStream ps = new PrintStream( System.out ) ;</span></p><p class="cs95E872D0"><span class="csC2DDF68C">		ps.println(&quot;hello&quot;);</span></p><p class="cs95E872D0"><span class="csC2DDF68C">		ps.println(25);</span></p><p class="cs95E872D0"><span class="csC2DDF68C">		ps.println(45.67);</span></p><p class="cs95E872D0"><span class="csC2DDF68C">		ps.println(false);</span></p><p class="cs95E872D0"><span class="csC2DDF68C">	}</span></p><p class="cs95E872D0"><span class="csC2DDF68C">}	</span></p><p class="cs95E872D0"><span class="cs57154F9C">&nbsp;</span></p></body>
</html>
